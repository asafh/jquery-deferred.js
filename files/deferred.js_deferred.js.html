<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>deferred.js\deferred.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: deferred.js\deferred.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(exports, globals) {
	&quot;use strict&quot;;
	var require = typeof require !== &quot;undefined&quot; ? require : function(p) {
		return globals[p];
	};
	var toolous = require(&quot;toolous&quot;);

	&#x2F;&#x2F;=============================Callback lists=============================
	&#x2F;**
	 * Utility object to contain a list of callbacks that can be fired with arguments and a context. &lt;br&#x2F;&gt;
	 * Callback lists can be configured to delete listeners upon file (i.e. &#x27;once&#x27;),
	 * and&#x2F;or to retain last fired arguments and context to send to newly add listeners (i.e. &#x27;memory&#x27;)
	 * @param {Object} options optional callback options
	 * @param {boolean} options.once  true if to remove listeners after firing. (default=false)
	 * @param {boolean} options.memory true if to keep the last value (and context) in memory and fire on new listeners (default=true)
	 *&#x2F;
	function CallbackList(options) {
		this._callbacks = [];
		this.options = toolous.merge({
			once : false,
			memory : true
		}, options);
	}

	&#x2F;**
	 * Binds cb as a listener for this CallbackList. &lt;br&#x2F;&gt;
	 * If there is a last value stored in memory (only if constructed with memory=true), cb is immediately called (and if once===true) then removed as a listener.
	 *&#x2F;
	CallbackList.prototype.add = function(cb) {
		this._callbacks.push(cb);
		if (this.firedArgs) {&#x2F;&#x2F;memory, firedArgs is always trueish if exists (since it is an array)
			cb.apply(this.firedContext, this.firedArgs);
			if (this.options.once) {&#x2F;&#x2F;clean listeners
				this._callbacks = [];
			}
			&#x2F;&#x2F;also removes the listener if once===true
		}
		return this;
	};
	&#x2F;**
	 * Fires all listeners with the given context and any arguments given after it
	 * @param {any} context the context to fire the callbacks with
	 * @param {any...} args the arguments to send all callback listeners
	 *&#x2F;
	CallbackList.prototype.fireWith = function(context) {
		var args = toolous.toArray(arguments, 1);
		&#x2F;&#x2F;ignore context as a parameter to the callback
		if (this.options.memory) {&#x2F;&#x2F;store value in memory
			this.firedArgs = args;
			this.firedContext = context;
		}
		toolous.forEach(this._callbacks, function(cb) {
			cb.apply(context, args);
		});
		if (this.options.once) {&#x2F;&#x2F;clean listeners
			this._callbacks = [];
		}
		return this;
	};
	&#x2F;**
	 * Fires all listeners with the null context and any arguments given to fire.&lt;br&#x2F;&gt;
	 * Equals to fireWith(nul,...)
	 * @param {any...} args the arguments to send all callback listeners
	 *&#x2F;
	CallbackList.prototype.fire = function() {&#x2F;&#x2F;Fire without context
		return this.fireWith.apply(this, toolous.toArray(arguments, 0, null));
	};
	&#x2F;&#x2F;===========================END Callback lists===========================

	&#x2F;&#x2F;========================= Finite State Machine =========================
	&#x2F;**
	 * Finite State Machine (Or a flying spaghetti monster). &lt;br&#x2F;&gt;
	 * A finite state machine has a state (string), and fires events when the state changes
	 * @param {Object} options Optional options object of the following format:
	 * @param {string} options.state the initial state name. (default=&quot;initial&quot;)
	 * @param {Object} options.stateOptions map between state names to their specific options. of the form {stateName: {once:bool, memory: bool, finalState: bool}}
	 * @param {boolean} options.once Default once value for states that don&#x27;t have a specific once value in options.stateOptions.  true if to remove listeners after firing. (default=true)
	 * @param {boolean} options.memory Default memory value for states that don&#x27;t have a specific memory value in options.stateOptions.  true if to keep the last value (and context) in memory and fire on new listeners (default=true)
	 * @param {boolean}: options.finalState: Default finalState value for states that don&#x27;t have a specific finalState value in options.stateOptions. - true if the FSM cannot change states once in this one. (default=false)
	 *&#x2F;
	function FSM(options) {
		options = toolous.merge({
			state : &quot;initial&quot;
		}, options);

		this._state = String(options.state);
		this._listeners = {};
		this._stateOpts = toolous.nvl(options.statesOptions, {});
		this._actualStateOpts = {};

		this._stateOptDefs = {
			once : !!toolous.nvl(options.once, true),
			memory : !!toolous.nvl(options.memory, true),
			finalState : !!toolous.nvl(options.finalState, false)
		};
	}

	&#x2F;**
	 * Returns the actual state options for &lt;code&gt;state&lt;&#x2F;code&gt;, as a merge between the default state options and the specific state options if any
	 * @param {Object} state
	 *&#x2F;
	FSM.prototype._getStateOptions = function(state) {
		var actual = this._actualStateOpts[state];
		if (!toolous.isDef(actual)) {
			this._actualStateOpts[state] = actual = toolous.merge({}, this._stateOptDefs, this._stateOpts[state]);
		}
		return actual;
	};
	FSM.prototype._getCallbackList = function(state) {
		var cbList = this._listeners[state];
		if (!cbList) {&#x2F;&#x2F;create CallbackList
			var cblOptions = this._getStateOptions(state);
			this._listeners[state] = cbList = new CallbackList(cblOptions);
		}
		return cbList;
	};
	&#x2F;**
	 * Adds func as a listener when the state changes to &lt;code&gt;state&lt;code&gt;
	 * @param {Object} state
	 * @param {Object} func
	 *&#x2F;
	FSM.prototype.on = function(state, func) {
		state = String(state);
		var cbList = this._getCallbackList(state);
		cbList.add(func);
	};

	&#x2F;**
	 * If state is defined, attempts to change to it, firing any listeners upon change. &lt;br&#x2F;&gt;
	 * Trying to change from a final state has no effect, doesn&#x27;t any event listeners and returns false.
	 * @param {string} state the state name to change into. undefined has no affect and just retrieves the state.
	 * @return the state after the change (if any change occurred) or false if trying to change from a final state.
	 *&#x2F;
	FSM.prototype.state = function(state,context) {
		if (toolous.isDef(state)) {&#x2F;&#x2F;change
			var currentStateOptions = this._getStateOptions(this._state);
			&#x2F;&#x2F;check if final
			if (currentStateOptions.finalState) {
				return false;
				&#x2F;&#x2F;Cannot change.
			}
			this._state = state = String(state);
			var args = toolous.toArray(arguments, 1); &#x2F;&#x2F;Removing state, keeping context &#x2F;&#x2F;2, context);
			&#x2F;&#x2F;skipping state
			var cbList = this._getCallbackList(state);
			cbList.fireWith.apply(cbList, args);
		}
		&#x2F;&#x2F;get
		return this._state;
	};
	&#x2F;&#x2F;======================= END Finite State Machine =======================

	&#x2F;&#x2F;=============================== Deferred ===============================
	var PROMISE_FUNCTIONS = [&quot;state&quot;, &quot;then&quot;, &quot;done&quot;, &quot;fail&quot;, &quot;always&quot;, &quot;pipe&quot;, &quot;progress&quot;];
	var STATES = {
		resolved : {
			fire : &quot;resolve&quot;,
			listen : &quot;done&quot;,
			thenIndex : 0,
			memory : true,
			once : true,
			query : &quot;isResolved&quot;,
			finalState : true
		},
		rejected : {
			fire : &quot;reject&quot;,
			listen : &quot;fail&quot;,
			thenIndex : 1,
			memory : true,
			once : true,
			query : &quot;isRejected&quot;,
			finalState : true
		},
		pending : {
			fire : &quot;notify&quot;,
			listen : &quot;progress&quot;,
			thenIndex : 2,
			memory : true,
			once : false
		}
	};

	&#x2F;**
	 * Promise exposes the only promise&#x27;s set of methods from a deferred object.
	 * @param {Object} deferred the deferred object of which methods to expose
	 * @param {any} this either a newly created object (when used with new), or an object to copy all of the promise methods to.
	 *&#x2F;
	function Promise(deferred) {
		var promise = this;
		toolous.forEach(PROMISE_FUNCTIONS, function(funcName) {
			promise[funcName] = function() {
				var ret = deferred[funcName].apply(deferred, arguments);
				return ret === deferred ? promise : ret;
				&#x2F;&#x2F;Not returning the deferred object.
			};
		});
		promise.promise = function() {
			return this;
		};
	}
	
	var id = 0;
	function Deferred(init) {
		if (!(this instanceof Deferred)) {&#x2F;&#x2F;must be called with new.
			return new Deferred(init);
		}
		this.id = ++id;
		var deferred = this;
		this._fsm = new FSM({
			state : &quot;pending&quot;,
			statesOptions : STATES
		});

		var promise = new Promise(this);
		this.promise = function(obj) {
			if (!toolous.isDef(obj)) {
				return promise;
			} else {
				toolous.merge(obj, promise);
				&#x2F;&#x2F;copy properties, instanceof will not work.
				return obj;
			}
		};
		
		toolous.forEachKey(Deferred.prototype, function(name,func) {
			deferred[name] = toolous.bind(func,deferred);
		});
		this.pipe = this.then;

		if (toolous.isDef(init)) {
			init.call(this, this);
		}
	}


	toolous.forEachKey(STATES, function(state, stateDefinition) {
		var fire = stateDefinition.fire, listen = stateDefinition.listen, query = stateDefinition.query;

		Deferred.prototype[listen] = function(cb) {&#x2F;&#x2F;Add listeners
			var callbacks = [];
			toolous.forEach(toolous.toArray(arguments), function(cb) {
				if (toolous.isArray(cb)) {
					callbacks = callbacks.concat(cb);
				}
				else if(toolous.isFunction(cb)) {
					callbacks.push(cb);
				}
			});
			&#x2F;&#x2F; console.log(callbacks);
			var me = this;
			toolous.forEach(callbacks, function(cb) {
				me._fsm.on(state, cb);
			});
			
			return this;
		};
		Deferred.prototype[fire] = function() {
			this[fire + &quot;With&quot;].apply(this, toolous.toArray(arguments, 0, this.promise()));
			return this;
		};
		Deferred.prototype[fire + &quot;With&quot;] = function(context) {
			this._fsm.state.apply(this._fsm, toolous.toArray(arguments, 1, state, context));
			return this;
		};

		if (query) {
			Deferred.prototype[query] = function() {
				return this._fsm.state() === state;
			};
		}
	});

	Deferred.prototype.always = function() {
		return this.done.apply(this, arguments).fail.apply(this, arguments);
	};
	Deferred.prototype.state = function() {
		return this._fsm.state();
	};
	Deferred.prototype.then = function(&#x2F;*doneFilter, failFilter, progressFilter*&#x2F;) {&#x2F;&#x2F;Took some inspiration from jQuery&#x27;s implementation at https:&#x2F;&#x2F;github.com&#x2F;jquery&#x2F;jquery&#x2F;blob&#x2F;master&#x2F;src&#x2F;deferred.js
		var args = arguments,
			retDeferred = new Deferred(), &#x2F;&#x2F;&quot;returns a new promise that can filter the status and values of a deferred through a function&quot;
			me = this; &#x2F;&#x2F;The deferred on which to perform the filter
		toolous.forEachKey(STATES, function(state, stateDefinition) {
			var i = stateDefinition.thenIndex,
			&#x2F;&#x2F; fire = stateDefinition.fire,
				listen = stateDefinition.listen,
				filter = toolous.isFunction(args[i]) &amp;&amp; args[i];
			me[listen](function() {
				var filterResult = filter &amp;&amp; filter.apply(this, arguments);
				if (Deferred.isObservable(filterResult)) {
					&#x2F;&#x2F;Case A: &quot;These filter functions can return&quot;...&quot;[an] observable
					&#x2F;&#x2F;			object (Deferred, Promise, etc) which will pass its 
					&#x2F;&#x2F;			resolved &#x2F; rejected status and values to the promise&#x27;s callbacks&quot;
					var filterPromise = filterResult.promise();
					&#x2F;&#x2F;Listening to any event on the observable, passing the
					&#x2F;&#x2F;call into the returned promise:
					toolous.forEachKey(STATES, function(_, chainStateDefinition) {
						filterPromise[chainStateDefinition.listen](function() {
							&#x2F;&#x2F;Prepending &#x27;this&#x27; in order to keep the same context
							&#x2F;&#x2F;the event which should be the same as given to the
							&#x2F;&#x2F;filter promise.
							var args = toolous.toArray(arguments, 0, this); 
							retDeferred[chainStateDefinition.fire+&quot;With&quot;].apply(retDeferred, args);
						});
					});
				} else {&#x2F;&#x2F;value, passed along
					&#x2F;&#x2F;Case B: &quot;If the filter function used is null, or not specified,
					&#x2F;&#x2F;			the promise will be resolved or rejected with the same
					&#x2F;&#x2F;			values as the original.&quot;
					&#x2F;&#x2F;Case C: &quot;These filter functions can return a new value to be
					&#x2F;&#x2F;			passed along to the promise&#x27;s .done() or .fail() callbacks&quot;
					
					&#x2F;&#x2F;If the context is the original deferred object, it wasn&#x27;t specified
					&#x2F;&#x2F;and we need to pass the returned deferred Otherwise we pass the new context 
					var context = (Deferred.isObservable(this) &amp;&amp; this.promise() === me.promise()) ?
										retDeferred.promise() : this;
					
					&#x2F;&#x2F;&quot;If the filter function used is null, or not specified, the promise
					&#x2F;&#x2F; will be resolved or rejected with the same values as the original.&quot;:
					var eventArgs = filter ? [filterResult] : toolous.toArray(arguments);
					
					retDeferred[stateDefinition.fire + &quot;With&quot;].apply(retDeferred,
														[context].concat(eventArgs));
					
				}
			});
		});
		return retDeferred.promise();
	};
	
	Deferred.isObservable = function(obj) {
		return obj !== null &amp;&amp; toolous.isDef(obj) &amp;&amp; (toolous.isFunction(obj.promise));
	};

	exports.when = function(single) {
		var whenArgs = toolous.toArray(arguments),
			resDef = new Deferred(),
			remaining = whenArgs.length,
			combinedState = {};

		if (remaining &lt;= 1) { &#x2F;&#x2F;Single 
			if(!Deferred.isObservable(single)) {
				&#x2F;&#x2F;&quot;If a single argument is passed to jQuery.when and it is not a
				&#x2F;&#x2F; Deferred or a Promise, it will be treated as a resolved Deferred
				&#x2F;&#x2F; and any doneCallbacks attached will be executed immediately&quot;
				single = new Deferred().resolveWith(null, single);
			}
			&#x2F;&#x2F;&quot;If a single Deferred is passed to jQuery.when, its Promise object
			&#x2F;&#x2F; (a subset of the Deferred methods) is returned by the method&quot;&quot;
			return single.promise();
		}
		
		&#x2F;&#x2F;Multiple values:
		toolous.forEach([&quot;resolve&quot;,&quot;notify&quot;], function(name) {
			combinedState[name] = {
				&quot;name&quot;: name,
				&quot;contexts&quot;: new Array(remaining),
				&quot;values&quot;: new Array(remaining),
				mark: function(i, context, value) {
					this.contexts[i] = context;
					this.values[i] = value;
				},
				createMarkFunction: function(i) {
					var me = this;
					return function(value) {
						me.mark(i, this, value);
					};
				},
				publish: function() {
					resDef[name+&quot;With&quot;].apply(resDef,[this.contexts].concat(this.values));
				}
			};
		});

		var valueReceived = function() { 
			--remaining;
			if (remaining === 0) {
				combinedState.resolve.publish();
			}
		};
		
		toolous.forEach(whenArgs, function(whenPart, i) {
			if (Deferred.isObservable(whenPart)) {
				whenPart = whenPart.promise();

				whenPart.done(combinedState.resolve.createMarkFunction(i));  &#x2F;&#x2F;Mark the ith deferred as returned.
				whenPart.done(valueReceived); &#x2F;&#x2F;Then count the value received and check if done
				
				whenPart.progress(combinedState.notify.createMarkFunction(i)); &#x2F;&#x2F;Mark progress
				whenPart.progress(toolous.bind(&quot;publish&quot;,combinedState.notify)); &#x2F;&#x2F;Notify progress
				
				whenPart.fail(function(error) { &#x2F;&#x2F;Notify failure
					resDef.rejectWith(this, error);
				});
			} else { &#x2F;&#x2F;Immidiate value:
				combinedState.resolve.mark(i, undefined, whenPart);
				valueReceived();
			}
		});

		return resDef.promise();
	};

	exports.Deferred = Deferred;

})( typeof exports === &#x27;undefined&#x27; ? this.deferred = {} : exports, this);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
